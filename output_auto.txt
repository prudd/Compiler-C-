ComprehensiveTest.c

VOID_TOKEN		void
ID_TOKEN		stupidMethod
LPAREN_TOKEN		(
INT_TOKEN		int
ID_TOKEN		zebra
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		walrus
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		kitten
RPAREN_TOKEN		)
LBRACE_TOKEN		{
INT_TOKEN		int
ID_TOKEN		a
LBRACKET_TOKEN		[
NUM_TOKEN		3
RBRACKET_TOKEN		]
ASSIGN_TOKEN		=
LBRACE_TOKEN		{
NUM_TOKEN		3
SEQUENCING_TOKEN	,
NUM_TOKEN		4
SEQUENCING_TOKEN	,
NUM_TOKEN		5
RBRACE_TOKEN		}
END_STATEMENT_TOKEN	;
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		kitten
ADD_TOKEN		+
ID_TOKEN		walrus
EQUAL_TOKEN		==
ID_TOKEN		zebra
RPAREN_TOKEN		)
LBRACE_TOKEN		{
ID_TOKEN		kitten
ASSIGN_TOKEN		=
ID_TOKEN		walrus
ADD_TOKEN		+
ID_TOKEN		zebra
END_STATEMENT_TOKEN	;
ID_TOKEN		walrus
ASSIGN_TOKEN		=
ID_TOKEN		zebra
SUBTRACT_TOKEN		-
ID_TOKEN		walrus
END_STATEMENT_TOKEN	;
ID_TOKEN		zebra
ASSIGN_TOKEN		=
ID_TOKEN		zebra
DIVIDE_TOKEN		/
ID_TOKEN		walrus
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
ELSE_TOKEN		else
LBRACE_TOKEN		{
ID_TOKEN		zebra
ASSIGN_TOKEN		=
ID_TOKEN		walrus
MULTIPLY_TOKEN		*
ID_TOKEN		walrus
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		kitten
LEQ_TOKEN		<=
ID_TOKEN		zebra
RPAREN_TOKEN		)
ID_TOKEN		zebra
ASSIGN_TOKEN		=
ID_TOKEN		walrus
END_STATEMENT_TOKEN	;
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		kitten
GEQ_TOKEN		>=
ID_TOKEN		walrus
RPAREN_TOKEN		)
ID_TOKEN		walrus
ASSIGN_TOKEN		=
ID_TOKEN		kitten
END_STATEMENT_TOKEN	;
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		zebra
NOT_EQUAL_TOKEN		!=
ID_TOKEN		kitten
RPAREN_TOKEN		)
ID_TOKEN		kitten
ASSIGN_TOKEN		=
ID_TOKEN		kitten
ADD_TOKEN		+
NUM_TOKEN		1
END_STATEMENT_TOKEN	;
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		kitten
LE_TOKEN		<
ID_TOKEN		zebra
RPAREN_TOKEN		)
ID_TOKEN		zebra
ASSIGN_TOKEN		=
ID_TOKEN		walrus
END_STATEMENT_TOKEN	;
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		zebra
GE_TOKEN		>
ID_TOKEN		walrus
SUBTRACT_TOKEN		-
NUM_TOKEN		2
RPAREN_TOKEN		)
ID_TOKEN		walrus
ASSIGN_TOKEN		=
ID_TOKEN		zebra
END_STATEMENT_TOKEN	;
WHILE_TOKEN		while
LPAREN_TOKEN		(
ID_TOKEN		zebra
GE_TOKEN		>
ID_TOKEN		walrus
RPAREN_TOKEN		)
ID_TOKEN		zebra
ASSIGN_TOKEN		=
ID_TOKEN		zebra
SUBTRACT_TOKEN		-
NUM_TOKEN		1
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}

SelectionSort.c

INT_TOKEN		int
ID_TOKEN		x
LBRACKET_TOKEN		[
NUM_TOKEN		10
RBRACKET_TOKEN		]
END_STATEMENT_TOKEN	;
INT_TOKEN		int
ID_TOKEN		minloc
LPAREN_TOKEN		(
INT_TOKEN		int
ID_TOKEN		a
LBRACKET_TOKEN		[
RBRACKET_TOKEN		]
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		low
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		high
RPAREN_TOKEN		)
LBRACE_TOKEN		{
INT_TOKEN		int
ID_TOKEN		i
END_STATEMENT_TOKEN	;
INT_TOKEN		int
ID_TOKEN		x
END_STATEMENT_TOKEN	;
INT_TOKEN		int
ID_TOKEN		k
END_STATEMENT_TOKEN	;
ID_TOKEN		k
ASSIGN_TOKEN		=
ID_TOKEN		low
END_STATEMENT_TOKEN	;
ID_TOKEN		x
ASSIGN_TOKEN		=
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		low
RBRACKET_TOKEN		]
END_STATEMENT_TOKEN	;
ID_TOKEN		i
ASSIGN_TOKEN		=
ID_TOKEN		low
ADD_TOKEN		+
NUM_TOKEN		1
END_STATEMENT_TOKEN	;
WHILE_TOKEN		while
LPAREN_TOKEN		(
ID_TOKEN		i
LE_TOKEN		<
ID_TOKEN		high
RPAREN_TOKEN		)
LBRACE_TOKEN		{
IF_TOKEN		if
LPAREN_TOKEN		(
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		i
RBRACKET_TOKEN		]
LE_TOKEN		<
ID_TOKEN		x
RPAREN_TOKEN		)
LBRACE_TOKEN		{
ID_TOKEN		x
ASSIGN_TOKEN		=
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		i
RBRACKET_TOKEN		]
END_STATEMENT_TOKEN	;
ID_TOKEN		k
ASSIGN_TOKEN		=
ID_TOKEN		i
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
RBRACE_TOKEN		}
RETURN_TOKEN		return
ID_TOKEN		k
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
VOID_TOKEN		void
ID_TOKEN		sort
LPAREN_TOKEN		(
INT_TOKEN		int
ID_TOKEN		a
LBRACKET_TOKEN		[
RBRACKET_TOKEN		]
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		low
SEQUENCING_TOKEN	,
INT_TOKEN		int
ID_TOKEN		high
RPAREN_TOKEN		)
LBRACE_TOKEN		{
INT_TOKEN		int
ID_TOKEN		i
END_STATEMENT_TOKEN	;
INT_TOKEN		int
ID_TOKEN		k
END_STATEMENT_TOKEN	;
ID_TOKEN		i
ASSIGN_TOKEN		=
ID_TOKEN		low
END_STATEMENT_TOKEN	;
WHILE_TOKEN		while
LPAREN_TOKEN		(
ID_TOKEN		i
LE_TOKEN		<
ID_TOKEN		high
SUBTRACT_TOKEN		-
NUM_TOKEN		1
RPAREN_TOKEN		)
LBRACE_TOKEN		{
INT_TOKEN		int
ID_TOKEN		t
END_STATEMENT_TOKEN	;
ID_TOKEN		k
ASSIGN_TOKEN		=
ID_TOKEN		minloc
LPAREN_TOKEN		(
ID_TOKEN		a
SEQUENCING_TOKEN	,
ID_TOKEN		i
SEQUENCING_TOKEN	,
ID_TOKEN		high
RPAREN_TOKEN		)
END_STATEMENT_TOKEN	;
ID_TOKEN		t
ASSIGN_TOKEN		=
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		k
RBRACKET_TOKEN		]
END_STATEMENT_TOKEN	;
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		k
RBRACKET_TOKEN		]
ASSIGN_TOKEN		=
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		i
RBRACKET_TOKEN		]
END_STATEMENT_TOKEN	;
ID_TOKEN		a
LBRACKET_TOKEN		[
ID_TOKEN		i
RBRACKET_TOKEN		]
ASSIGN_TOKEN		=
ID_TOKEN		t
END_STATEMENT_TOKEN	;
ID_TOKEN		i
ASSIGN_TOKEN		=
ID_TOKEN		i
ADD_TOKEN		+
NUM_TOKEN		1
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
RBRACE_TOKEN		}

CrappyCode.c

MULTIPLY_TOKEN		*
DIVIDE_TOKEN		/
INT_TOKEN		int
ERROR_TOKEN		INVALID_IDENTIFIER
ID_TOKEN		ng
LPAREN_TOKEN		(
INT_TOKEN		int
ERROR_TOKEN		INVALID_IDENTIFIER
RPAREN_TOKEN		)
LBRACE_TOKEN		{
IF_TOKEN		if
LPAREN_TOKEN		(
ERROR_TOKEN		UNSPECIFIED_ERROR
LPAREN_TOKEN		(
ERROR_TOKEN		INVALID_IDENTIFIER
EQUAL_TOKEN		==
NUM_TOKEN		2
RPAREN_TOKEN		)
RPAREN_TOKEN		)
LBRACE_TOKEN		{
ERROR_TOKEN		INVALID_IDENTIFIER
ASSIGN_TOKEN		=
NUM_TOKEN		4
ERROR_TOKEN		UNSPECIFIED_ERROR
NUM_TOKEN		65
END_STATEMENT_TOKEN	;
ERROR_TOKEN		INVALID_IDENTIFIER
ASSIGN_TOKEN		=
NUM_TOKEN		87
ERROR_TOKEN		UNSPECIFIED_ERROR
NUM_TOKEN		3
END_STATEMENT_TOKEN	;
ERROR_TOKEN		INVALID_IDENTIFIER
ASSIGN_TOKEN		=
NUM_TOKEN		8
ERROR_TOKEN		UNSPECIFIED_ERROR
NUM_TOKEN		4
ERROR_TOKEN		UNSPECIFIED_ERROR
ID_TOKEN		fred
ERROR_TOKEN		UNSPECIFIED_ERROR
NUM_TOKEN		9
END_STATEMENT_TOKEN	;
RBRACE_TOKEN		}
ERROR_TOKEN		INVALID_IDENTIFIER
ASSIGN_TOKEN		=
ERROR_TOKEN		INVALID_INTEGER
RBRACE_TOKEN		}

